# Application_Test

### 이민아 



---

## Index



- [애플리케이션 테스트](#application-test)

  - 실행 여부 (정적 / 동적)
  - 테스트 기반 (명세 / 구조 / 경험)
  - 시각 (확인 / 검증)
  - 목적 (회복 / 안전 / 강도 / 성능 / 구조 / 회귀 / 병행)

- [화이트박스 테스트 (논리 / 구조 / 동적)](#화이트박스-테스트)

  - 기초 경로 검사
  - 제어 구조 검사
    - 조건 검사
    - 루프 검사
    - 데이터 흐름 검사

- [블랙박스 테스트 (기능 / 명세 / 동적)](#블랙박스-테스트)

  - 동치 분할 검사
  - 경계값 분석
  - 원인 효과 그래프 검사 
  - 오류 예측 검사
  - 비교 검사

- [통합 테스트 (개발 단계)](#통합-테스트)

  - 단위 테스트
  - 통합 테스트 
    - 점진 (상향식 / 하향식 / 혼합식)
    - 비점진 (빅뱅)
  - 시스템 테스트
  - 인수 테스트
  - 회귀 테스트

- [테스트 프로세스](#테스트-프로세스)

  - 테스트 케이스
  - 테스트 시나리오
  - 테스트 오라클
  - 테스트 하네스
  - 테스트 커버리지
  - 테스트 자동화 도구
  
- [결함 관리](#결함-관리)

- [애플리케이션 성능](#애플리케이션-성능)

  


----

## 애플리케이션 테스트



### 1. 정의

#### (1) 애플리케이션 테스트

개발된 응용 애플리케이션이나 시스템이 **사용자**가 요구하는 **기능과 성능, 사용성, 안정성** 등 을 만족하는지 확인하고, 노출되지 않은 숨어있는 소프트웨어의 **결함**을 찾아내는 활동

#### (2) 필요성

오류 발견 관점 / 오류 예방 관점 / 품질 향상 관점

#### (3) 테스트 원리 ★

- 완벽 불가 : 결함 **감소**는 가능하지만 없다고 증명 불가
- 결함 집중 **(파레토 법칙)** : **20% 코드에**서 80% 결함
- **살충제 패러독스** : **동일한 테스트 케이스로** 동일한 테스트 반복하면 더이상 결함이 발견되지 않아서 테스트케이스 **주기적 혹은 지속적 보완 및 개선**
- **오류 부재의 궤변** : **결함** 모두 제거해도 **사용자 요구사항** 만족하지 못하면 **품질** 높다고 말할 수 없음
- 정황 의존 테스팅 : **SW 특징, 테스트 환경, 테스터 역량** 등 정황에 결과 상이

- 초기에 테스팅 시작 : 테스팅 결과를 단시간

#### (4) 테스트 산출물

- 테스트 계획서 : 수행을 **계획**한 문서
- 테스트 케이스 : 테스트 **항목** 명세서, 설계 산출물
  - **요구사항**을 준수하는지 확인하기 위해 설계된 명세서
  - **입력값, 실행 조건, 기대 결과**로 구성된 테스트 항목의 명세서
- 테스트 **시나리오** : 테스트 **절차** 명세
  - 수행을 위한 **여러 개의 테스트 케이스의 집합**
  - 테스트 **절차**를 명세한 문서
- 테스트 결과서  : 테스트 리프팅

#### (5) 테스트 프로세스

테스트 계획 → 테스트 분석 및 디자인 → 테스트 케이스 및 시나리오 작성 → 테스트 수행  → 테스트 결과 평가 및 리포트 → **결함 추적 및 관리**



### 2. 분류

#### (1) 프로그램 실행 여부에 따른 테스트 (정적 / 동적) ★

- 정적 : 실행하지 않고 **명세서나 소스코드** 대상 분석
  - **동료검토** : 명세서 **작성자가** 내용 직접 설명, 동료들이 들으면서 검토
  - **워크스루** : 검토 회의 **전** 요구사항 명세서를 **미리 배포해** 짧은 검토회의를 통해 결함 발견
  - **(코드) 인스펙션** : 정적 테스트의 **가장 일반적** 유형으로 명세서 **작성자 제외한 다른 검토 전문가** / 사전에 정의된 코드 작성 규칙 기반 소스코드 점검 / 빌드도구와 연계하여 빌드, 배포 수행시 자동 점검 가능
- **동적** : 프로그램 **실행**하여 개발 **모든** 단계에서 가능
  - **화이트박스** 테스트(**내부 논리**) 
  - **블랙박스** 테스트(**외부 사용자** **요구**사항 명세 **기능**)

#### (2) 테스트 기반에 따른 테스트 (명세 / 구조 / 경험) ★

- **명세 기반 테스트** : **요구사항에 대한 명세**를 빠짐없에 테케 만들고 구현 확인 **(기능 블랙박스)**
  - 동등 분할(동치분할)
  - 경계값 분석
  - 결정 테이블
  - 유스케이스
  - 상태 전이
- **구조 기반 테스트** : **내부 논리 흐름**에 따라 테케 작성 확인 **(논리 화이트박스)**
  - **구문** : **모든 명령문을** 적어도 한 번 수행
  - 변경조건-결정
  - 다중조건 : 조건/결정 커버리지를 **향상**시켜 각 조건식이 **다른 개별 조건식에 영향을 받지 않고 전체 조건식에 독립적으로 영향**을 주도록
  - **결정** : **전체** 조건식이 **적어도 한 번은 참과 거짓**의 결과
  - **조건** :  **각 개별** 조건식이 **참/거짓 한 번만 모두 갖도록 개별 조건식을 조합**
  - **조건-결정** :  **각 조건(개별조건)**과 **전체 조건식이 적어도** **한 번은 참과 거짓**의 결과
- **경험 기반 테스트** : **유사 기술 등에 대한 테스터** 경험 기반  **(기능 블랙박스)**
  - 에러추정
  - 체크리스트
  - 탐색적테스팅

#### (3) 시각에 따른 테스트 (확인 / 검증) ★

- **확인(Validation)** 
  - **사용자** 시각 (사용자가 요구한 대로 정상적 작동 테스트)
  - **결과** (**명세서** 대로 완성) 
- **검증(Verification)** 
  - **개발자** 시각 
  - **과정** (올바른 제품을 생산하고 있는지)

#### (4) 목적에 따른 테스트 (회복 / 안전 / 강도 / 성능 / 구조 / 회귀 / 병행)

- 회복 : 여러 **결함 주어 실패 후 복구**
- 안전 : **시스템 보호 도구가 불법 침입**으로부터 보호 확인**(보안적 결함)**
- **강도(스트레스)** : 과도한 정보량이나 빈도 등을 부과하여 **과부하시** 정상적 실행 여부
- 부하 : **임계치의 한계**에 도달할 때까지 **부하를 꾸준히 증가**시키면서 진행하고 발생시키는 부하는 실제 시스템에 적용될 예상 트래픽
- 성능 : 실시간 **성능이나 효율성(응답시간, 처리량)**
- 구조 : **내부 논리적** 경로, **소스코드 복잡도**
- **회귀** : **변경 수정**된 코드에 **새로운 결함 여부** 
- 병행 : **변경과 기존** SW에 동일한 데이터 입력하여 결과 비교



---

## 화이트박스 테스트



### 1. 동적 테스트 (내부 논리) ★

#### (1) 정의

- 프로그램 **내부 로직(모듈의 원시코드)**을 보면서 **모든 경로** 테스트하여 **테스트 케이스를 설계**하는 수행하는 테스트
- 원시 코드의 **모든** 문장을 한 번씩 수행
- 모듈 안의 작동 **직접** 관찰

#### (2) 유형

- **기초 경로 검사**
- **제어 구조** 검사
  - 조건 검사
  - **루프** 검사
  - 데이터 흐름 검사

#### (3) 검증 기준

- 문장 검증 기준
- 조건 검증 기준
- 분기 검증 기준
- 분기/조건 검증 기준



### 2. 유형

#### (1) 기초 경로 검사 ★

- 테스트 케이스 설계자가 절차적 설계의 논리적 복잡성 측정
- 실행 경로의 기초를 정의하는 지침으로 결과가 사용

#### (2) 제어 구조 검사 ★

- **조건** 검사 : **논리적 조건** 테스트
- **루프** 검사 : **반복 구조**에 초점을 맞춰 실시하는 테스트 케이스 설계 
- **데이터 흐름** 검사 : **변수의 정의**와 **변수의 사용 위치**에 초점 



---

## 블랙박스 테스트



### 1. 동적 테스트 (외부 기능) ★

#### (1) 정의 

- 프로그램 **외부 사용자**의 **요구사항 명세**를 보면서 수행하는 테스트
- 특정 기능을 알기 위해서 **각 기능**이 완전히 작동되는 것을 입증
- **인터페이스**에서 실시되는 테스트 

#### (2) 유형

- **동치 분할 검사**
- **경계값 분석**
- 원인 효과 그래프 검사 
- 오류 예측 검사
- 비교 검사
- 유스케이스



### 2. 유형

#### (1) 동치 분할 검사 ★

- **입력 자료**에 초점 맞춰 테케 만들고 검사
- 동등분할검사, 균등분할검사, 동치클래스분해테스트
- **유효값과 무효값** 나눠야할 경우

#### (2) 경계값 분석 (한계값 분석) ★

- 입력 자료에만 치중한 **동치분할기법 보완** 
- 입력 조건 **경계값** 테케로 선정하여 검사
- 0 <= x <= 10일 때 0, 10, 11 

#### (3) 원인 효과 그래프 검사 

- 입력 **데이터 간**의 **관계와 출력에** 영향을 미치는 상황 분석
- **효용성**이 높은 테케 선정하여 검사

#### (4) 오류 예측 검사

- **과거** 경험이나 확인자 감각

#### (5) 비교 검사

- **여러 버전**의 프로그램에 **동일한 테스트** 자료 제공 **동일 결과 출력**



---

## 통합 테스트



### 1. 개발 단계에 따른 애플리케이션 테스트

> 폭포수 모델의 변형인 **V모델**은 테스트 단계 추가 확장 **(통합 → 시스템 → 인수)**

#### (1) 단위 테스트 ★

> 코딩 직후 소프트웨어 설계의 최소 단위인 **모듈이나 컴포넌트** 초점
>
> **사용자 요구사항**을 기반으로 한 **기능성 테**스트 우선하여 **화이트박스 주로** 

- 구조 기반 테스트 : 내부 구조 및 복잡도 **화이트박스**

- 명세 기반 테스트 : 목적 및 실행코드 기반 **블랙박스**

- **JUnit** : 자바 프로그래밍 언어용 **단위 테스트** 도구

  - Assert 메소드 

    ![image-20210705015131731](Application_Test.assets/image-20210705015131731.png)

#### (2) 통합 테스트 ★

> **단위 테스트가 완료**된 **모듈들을 결합**하여 하나의 시스템으로 완성시키는 과정에서의 테스트
>
> **인터페이스의 흐름**이 정상적으로 작동하는지 중점

#### (3) 시스템 테스트 

> 개발된 SW가 해당 시스템에서 **완벽히** 수행되는가 점검
>
> **실제 환경과 유사한 환경**에서 진행
>
> 개발 조직과는 **독립된 테스트** 조직에서 수행되어야 하며 **사전 요구사항이 명확**
>
> 단위, 통합 테스트가 **가능한 완벽히 완료되어** 기능상 문제가 없는 상태

- 구조 기반 테스트 : 내부 구조 및 복잡도 **화이트박스(기능적 요구사항)**
- 명세 기반 테스트 : 목적 및 실행코드 기반 **블랙박스(비기능적 요구사항)**

#### (4) 인수 테스트 ★

> 사용자의 요구사항을 충족하는지 중점을 두고 테스트

- 알파 테스트

  - 개발자의 장소에서 사용자가 **개발자 앞에서**

  - **통제**된 환경

  - 오류와 사용상의 문제점을 사용자와 **개발자가 함께 확인**

- 베타 테스트

  - 선정된 최종 사용자가 **여러명의 사용자 앞에**서 행한다
  - 선발된 잠재고객이 **일정 기간 무료로 사용**
  - 개발자에 의해 **제어되지 않은 상태**
  - 오류와 문제점을 기록하고 개발자에게 **주기적 보고**

#### (5) 회귀 테스트

- 이미 테스트된 프로그램의 테스팅 반복
- 통합 테스트로 인해 변경된 모듈이나 컴포넌트에 새로운 오류가 있는지 확인



### 2. 통합 테스트

#### (1) 비점진적 통합방식

- 단계적 통합 절차 **없이** 모든 모듈 미리 결합된 상태 전체 테스트
- **작은 SW** 유리 단시간
- 오류 발견 및 장애 위치 파악 및 수정 어려움
- **빅뱅 통합** 테스트 
  - 모듈 간의 상호 **인터페이스 고려하지 않고** 
  - 단위 테스트가 끝난 모듈 한꺼번에 결합
  - 실제 모듈 테스트 진행

#### (2) 점진적 통합방식 ★

- 모듈 단위 단계적 통합하며 테스트
- 오류 수정 용이 인터페이스 관련 오류 완전히 테스트할 가능성 높음
- 유형
  - **하향식(스텁/Stub)** : 상위 모듈에서 하위 모듈로 통합
  
    모듈 및 모든 **하위** 컴포넌트를 대신하는 **더미 모듈**
  
    길이 우선 방식 혹은 너비 우선 방식
  
  - **상향식(드라이버/Driver)** : 하위 모듈에서 상위 모듈로 통합
  
    상위의 모듈에서 데이터의 **입력과 출력을 확인하는 모듈**
  
  - 혼합식 : 하위 수준에서는 상향식 통합, 상위 수준에서는 하향식 통합하여 최적 테스트 지원(샌드위치)
  
  - 백본통합 : **소프트웨어 리스크가 높은 것을 우선적**으로 통합하**고 드라이버, 스텁은 필요에 따라 사용**

#### (3) 회귀 테스트

- 이미 테스트된 프로그램의 테스팅 반복
- 통합 테스트로 인해 변경된 모듈이나 컴포넌트에 새로운 오류가 있는지 확인



---

## 테스트 프로세스



### 1. 테스트 프로세스

#### (1) 과정 ★

테스트 계획 → 테스트 분석 및 디자인 → 테스트 케이스 및 시나리오 작성 → 테스트 수행  → 테스트 결과 평가 및 리포트 → **결함 추적 및 관리**

#### (2) 산출물

- 테스트 계획서 : 수행을 계획한 문서
- 테스트 케이스
  - **요구사항**을 준수하는지 확인하기 위해 설계된 명세서
  - **입력값, 실행 조건, 기대 결과**로 구성된 테스트 항목의 명세서
- 테스트 **시나리오**
  - 수행을 위한 **여러 개의 테스트 케이스의 집합**
  - 테스트 **절차**를 명세한 문서
- 테스트 결과서 



### 2. 테스트 케이스 ★

#### (1) 정의

- **요구사항**을 준수하는지 확인하기 위해 설계된 명세서
- **입력값, 실행 조건, 기대 결과**로 구성된 테스트 항목의 명세서

#### (2) 작성 과정

- 테스트 계획 검토 및 자료 확보
- **위험 평가 및 우선순위** 결정
- 테스트 **요구사항** 정의
- 테스트 **구조** 설계 및 테스트 **방법** 결정
- 테스트 **케이스** **정의**
- 테스트 케이스 타당성 확인 및 유지보수

#### (3) 테스트 커버리지

- **구문**
- 변경조건-결정
- 다중조건
- **결정**
- **조건**
- **조건-결정**



### 3. 테스트 시나리오 ★

#### (1) 정의

- 적용하는 **순서**에 따라 수행을 위한 **여러 개의 테스트 케이스의 집합**
- 테스트 **절차**를 명세한 **문서**

#### (2) 작성 사항

- 순서에 대한 구체적 절차
- 사전 조건
- 입력 데이터
- 시스템별, 모듈별, 항목별 등과 같이 여러 개의 시나리오 분리 작성
- 식별자 번호, 순서 번호, 테스트 데이터, 테스트 케이스, 예상 결과, 확인 등을 포함해서 작성
- 유스 케이스(Use Case) 간 업무 흐름이 정상적인지 테스트 가능



### 4. 테스트 오라클 ★

#### (1) 정의

- 테스**트 경로가 올바른지** 판단하기 위해 **사전에 정의된 참 값을 대입**하여 비교하는 기법 및 활동

#### (2) 유형

- **참** 오라클 : **모든** 테케의 입력값에 대해 기대하는 결과 제공(모든 어류 검출)
- **샘플링** 오라클 : **특정한** 테케 입력값에 대해 기대하는 결과
- **추정** 오라클 : **샘플링 오라클을 개선**하여 **나머지** 입력값들에 대해서는 **추정**으로 처리하는 오라클
- **일관성** 검사 오라클 : 애플리케이션 **변경**이 있었을 때 테케 **수행 전과 후의** 결과 값이 동일한지 확인



### 5. 테스트 하네스 ★

- 애플리케이션 **컴포넌트 및 모듈**을 테스트하는 환경의 일부분
- 테스트를 지원하기 위한 **코드와 데이터**
- **단위 또는 모듈 테스트**에 사용하기 위해 코드 개발자가 작성하는 요소



### 6. 테스트 커버리지

> **구문**, 변경조건-결정, 다중조건, **결정, 조건, 조건-결정**
>
> **구조 기반 테스트 (화이트박스 테스트)**
>
> 테스트 범위를 측정하는데 테스트 **품질 측정 기술**

#### (1) 결정 커버리지 

- 프로그램 내 **전체** 조건식이 **적어도 한 번은 참과 거짓**의 결과를 수행하는 **테스트케이스**

#### (2) 조건 커버리지 

- 전체 조건식 결과와 관계없이 **각 개별** 조건식이 **참/거짓 한 번만 모두 갖도록 개별 조건식을 조합**하는 테스트 커버리지

#### (3) 조건-결정 커버리지

- 결정 명령문 내의 **각 조건(개별조건)**과 **전체 조건식이 적어도** **한 번은 참과 거짓**의 결과를 수행하는 **테스트케이스**

#### (4) 변경조건-결정 커버리지 

- 조건/결정 커버리지를 **향상**시켜 각 조건식이 **다른 개별 조건식에 영향을 받지 않고 전체 조건식에 독립적으로영향**을 주도록한 코드 커버리지

#### (5) 구문 커버리지

- **모든 명령문을** 적어도 한 번 수행
- **조건문 결과 관계없이** 구문 실행 **개수**로 계산



### 7. 테스트 자동화 도구 유형 ****

#### (1) 정의

- 사람이 반복적으로 수행하던 테스트 절차에서 휴먼 에러 줄이고
- 테스트 정확성 유지 및 품질 향상

#### (2) 유형

- **정적** 분석 도구 : 프로그램 **실행하지 않고** **소스코드**에 대한 코딩 표준, 코딩 스타일, 코드 복잡도 및 남은 결함 등 발견
- **성능** 테스트 도구 : **처리량, 응답시간, 경과시간, 자원사용률** 등을 **인위적**으로 적용한 **가상의 사용자**를 만들어 테스트 수행
  - JMeter
  - Load UI
- 시스템 모니터링 도구 
  - 스카우터 : 애플리케이션 및 OS 자원 모니터링 기능 제공
- 테스트 **실행** 도구 : **스크립트 언어** 사용하여 테스트 **실행**(테스트 데이터, 테스트 수행 방법 등 포함)
- 테스트 **통제** 도구 : 테스트 계획 및 관리, 수행, 결함 관리 등을 수행하는 도구로 **형상 관리 도구, 결함 추적/관리 도구** 
- 테스트 **하네스** 도구 : 실행될 **환경을** **시뮬레이션**하여 **컴포넌트 및 모듈이** 정상적으로 테스트되도록 하는 **단위테스트 도구로 개발자가 작성**

#### (3) 관련 용어

- 테스트 케이스 : **입력값, 실행 조건, 기대 결과 등 집합**
- 테스트 슈트 : 테스트 대상 **컴포넌트나 시스템**에 사용되는 테스트케이스 **집합**
- 테스트 스크립트 : 자동화된 테스트 케이스 **절차와 실행 순서** 명시
- 목 오브젝트 : 사용자 행위를 조건부로 사전에 입력해두면 예정된 행위 **수행 객체**



---

## 결함 관리



### 1. 정의

#### (1) 정의

- 오류발생, 작동실패 등과 같이 SW가 개발자가 설계한 것과 다르게 동작하거나 다른 결과가 발생되는 것
- 에러 / 오류 : 결함의 원인이 되는 것으로 인간의 실수
- 결함 / 버그 : 에러나 오류의 원인이 되어 SW에 포함
- 실패 / 문제 : SW 경함이 시스템 실행시 발생되어 시각적 문제 발생

#### (2) 유형

- 시스템 결함 : 애플리케이션 **환경이나 DB 처리** (시스템 다운, 애플리케이션 작동 정지, 종료, 응답시간 지연)
- 기능 결함 : 애플리케이션 기획, 설계, **업무 시나리오** 등의 단계에서 유입된 결함(사용자 요구사항 미반영/불일치, 스크립트 오류, 타 시스템 연동시 오류)
- GUI 결함 : 사용자 **화면 설계**에서 발생 (UI 비일관성, 데이터 타입 표시 오류, 부정확한 커서/메세지 오류)
- 문서 결함 : **기획자, 사용자, 개발자** 간의 의사소통 및 기록 원활하지 않음(사용자의 온라인 오프라인 메뉴얼의 불일치)



### 2. 과정

#### (1) 처리 과정 

결함 관리 계획 → 결함 기록 → 검토 → 수정 → 재확인 → 결함 상태 추적 및 모니터링 활동 → 최종 결함 분석 및 보고서 작성

#### (2) 추적 과정

- 결함 등록(Open) → 검토(Review) → 할당(Assigned) → 수정(Resolved) → 종료(Closed) → **해제(Clarified)**

- **고정(Fixed)** : 개발자가 필요한 **변경** 작업을 수행하여 **결함 수정** 작업을 **완료**한 상태



### 3. 측정 지표

#### (1) 측정 지표

- 결함 분포 : 모듈 또는 컴포넌트 특정 **속성**에 해당하는 **결함 수** 측정
- 결함 추세 : 테스트 진행 **시간**에 따른 **결함 수의 추이** 분석
- 결함 에이징 : 특정 결함 상태 **지속 시간**

#### (2) 심각도 / 우선 순위

- 결정적(Critical), 높음(High), 보통(Medium), 낮음(Low) 또는 즉시해결, 주의 요망, 대기, 개선 권고 등

- 높음 : 프로세스 진행 불가
- 보통 : 시스템 흐름에 영향
- 낮음 : 시스템 흐름에 영향 미치지 않음



---

## 애플리케이션 성능



### 1. 애플리케이션 성능 

- 사용자가 요구한 기능을 최소한의 자원을 사용하여 초대한의 많은 기능을 신속하게 처리하는 정도 



### 2. 측정 지표 ★

#### (1) 처리량

- 일정 시간 내 **처리하는 일의 양(트랜잭션의 수)**
- 웹 애플리케이션의 경우 **시간당 페이지 수**

#### (2) 응답시간 

- **요청**을 전달한 시간(**입력이 끝난** 후)부터 **응답 출력(완료된 상태)**이 도착하는데 걸리는 시간
- 웹 애플리케이션의 경우 메뉴 클릭시 해당 메뉴 나타나는 시간

#### (3) 경과 시간 

- **작업을** **의뢰**한 시간(**요구를 입력**한 시점)부터 **처리**가 완료될 때(**트랜잭션 처리 후 그 결과 출력 완료 / 완료되지 않은 상태**)까지 시간

#### (4) 자원 사용률

- **의뢰한 작업** 처리하는 동안의 **CPU, 메모리 및 네트워크 사용량**



### 3. 소스코드 최적화

#### (1) 소스코드 

- 클린 코드 : 누구나 쉽게 이해하고 수정 및 추가하는 단순 명료한 코드

- 나쁜 코드 

  - 로직이 서로 얽혀있는 스파게티 코드 등 로직 복잡

  - 클린코드로 수정하면 성능 개선

#### (2) 최적화 유형 

- 클래스 분할 배치 : **하나의 클래스는** 하나의 역할만 (**응집도를 높이고 크기를 작게 작성)**
- **느슨한 결합** : **인터페이스 클래스**를 이용하여 **추상화**된 자료 구조와 **메소드를** 구현함으로써 클래스 간의 **의존성 최소화**
- 코딩 형식 준수, 좋은 이름, 주석문

#### (3) 작성 원칙

- 가독성
- 단순성
- 의존성 배제
- 중복성 최소화
- 추상화

#### (4) 품질 분석 도구

- 정적 분석 도구 : 코드 실행하지 않고 분석
- 동적 분석 도구 : 실행하여 코드 존재 메모리 누수 현황 파악 및 스레드의 결함 분석





---

## References



- 시나공 정보처리기사 실기 대비용 핵심요약




---

